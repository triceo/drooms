package org.drooms.strategy.hungry

import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import org.drooms.api.Move;
import org.drooms.api.Node;
import org.drooms.api.Edge;
import org.drooms.api.Collectible;
import org.drooms.impl.logic.facts.Positioned;
import org.drooms.impl.logic.facts.CurrentTurn;
import org.drooms.impl.logic.facts.CurrentPlayer;
import org.drooms.impl.logic.events.PlayerMoveEvent;
import org.drooms.impl.logic.events.CollectibleAdditionEvent;
import org.drooms.impl.logic.events.CollectibleRemovalEvent;
import org.drooms.impl.logic.PathTracker;
import org.slf4j.Logger;

global Logger logger;
global PathTracker tracker;

declare AvailableMove
    x: int
    y: int
    move: Move
end

declare CurrentPosition
    node: Node
end

declare PresentCollectible
    node: Node
    collectible: Collectible
end

declare AvailableCollectible
    node: Node
    collectible: Collectible
    path: List
end

declare ReachableCollectible
    node: Node
    collectible: Collectible
    path: List
end

declare TargettedCollectible
    node: Node
    collectible: Collectible
    path: List
end

declare PlayerMoveEvent
    @role (event)
end

declare CollectibleAdditionEvent
    @role (event)
end

declare CollectibleRemovalEvent
    @role (event)
end

declare entry-point rewardEvents
    @doc("A stream of reward events generated by the game")
end

declare entry-point gameEvents
    @doc("A stream of non-reward events generated by the game")
end

declare entry-point playerEvents
    @doc("A stream of events generated by players")
end

rule "Determine current position of a player"
salience 50
when
    CurrentPlayer($p: player)
    $added: PlayerMoveEvent(player == $p) from entry-point "playerEvents"
    not PlayerMoveEvent(player == $p, this after $added) from entry-point "playerEvents"
then
    insertLogical (
        new CurrentPosition($added.getNodes().getFirst())
    );
end

rule "Find all collectibles that are present"
salience 50
when
    $added: CollectibleAdditionEvent($c: collectible) from entry-point "gameEvents"
    not CollectibleRemovalEvent(collectible == $c, this after $added) from entry-point "gameEvents"
then
    insertLogical (
        new PresentCollectible($added.getNode(), $added.getCollectible())
    );
end

rule "From present collectibles, find those to which we have a path"
salience 40
when
    CurrentPosition($startNode: node)
    PresentCollectible($c: collectible, $endNode: node)
    eval(tracker.getPath($startNode, $endNode).size() > 0);
then
    insertLogical (
        new AvailableCollectible($endNode, $c, tracker.getPath($startNode, $endNode))
    );
end

rule "From available collectibles, find those that can be reached in time"
salience 30
when
    CurrentTurn($turn: number)
    AvailableCollectible($n: node, $p: path, $c: collectible, $c.expires() == false || $c.expiresInTurn() > ($turn + $p.size()))
then
    insertLogical (
        new ReachableCollectible($n, $c, $p)
    );
end

############################# TARGET LOCKING ###################################

rule "Untarget when collectible disappears"
salience 29
when
    $t: TargettedCollectible($c: collectible)
    CollectibleRemovalEvent(collectible == $c) from entry-point "gameEvents"
then
    retract ($t);
end

rule "Untarget when path to collectible disappears"
salience 29
when
    $t: TargettedCollectible($c: collectible)
    not ReachableCollectible(collectible == $c)
then
    retract ($t);
end

rule "Recreate path when the underlying collectible changes"
salience 28
no-loop
when
    CurrentPosition($startNode: node)
    $t: TargettedCollectible($c: collectible, $endNode: node)
    ReachableCollectible(collectible == $c)
then
    modify ($t) {
        setPath(tracker.getPath($startNode, $endNode))
    }
end

rule "If not targetted, pick the closest collectible"
salience 25
no-loop
when
    not TargettedCollectible()
    $r: ReachableCollectible($n: node, $c: collectible, $p: path)
    not ReachableCollectible(this != $r, path.size() < $p.size())
then
    insert (
        new TargettedCollectible($n, $c, $p)
    );
end

rule "Don't retarget unless a better collectible is exactly as far"
salience 25
when
    $t: TargettedCollectible($n: node, $c: collectible, $p: path)
    $r: ReachableCollectible(collectible != $c, path.size() <= $p.size(), collectible.points > $c.points)
then
    modify ($t) {
        setNode($r.getNode()),
        setCollectible($r.getCollectible()),
        setPath($r.getPath())
    };
end

rule "Navigate to the targetted collectible"
salience 20
when
    CurrentPosition($currentNode: node)
    $r: TargettedCollectible($c: collectible, $p: path, $p.size > 0)
then
    Edge currentEdge = (Edge)$p.get(0);
    Node nodeA = currentEdge.getNodes().getLeft();
    Node nodeB = currentEdge.getNodes().getRight();
    Node nextNode = (nodeA == $currentNode) ? nodeB : nodeA;
    Move m = null;
    // determine the move that would be required to get closer to the target
    if (nextNode.getX() == $currentNode.getX()) {
        // movement on the Y axis
        if (nextNode.getY() < $currentNode.getY()) {
            m = Move.DOWN;
        } else {
            m = Move.UP;
        }
    } else {
        // movement on the X axis
        if (nextNode.getX() < $currentNode.getX()) {
            m = Move.LEFT;
        } else {
            m = Move.RIGHT;
        }
    }
    // add the move towards that target as available
    logger.info("Target: " + $c.toString() + " @ " + $r.getNode().toString() + "; Next: " + nextNode.toString() + " Move: " + m.toString() + ".");
    insertLogical (
        new AvailableMove(nextNode.getX(), nextNode.getY(), m)
    );
end

################################################################################
######                     IN CASE NO COLLECTIBLES FOUND                   #####
################################################################################

rule "Determine whether a position to the left is available to be moved into"
salience 10
when
    not TargettedCollectible()
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == ($x - 1), y == $y)
then
    logger.debug("LEFT fallback.");
    insertLogical (
        new AvailableMove($x - 1, $y, Move.LEFT)
    );
end

rule "Determine whether a position to the right is available to be moved into"
salience 10
when
    not TargettedCollectible()
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == ($x + 1), y == $y)
then
    logger.debug("RIGHT fallback.");
    insertLogical (
        new AvailableMove($x + 1, $y, Move.RIGHT)
    );
end

rule "Determine whether a position to the top is available to be moved into"
salience 10
when
    not TargettedCollectible()
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == $x, y == ($y + 1))
then
    logger.debug("UP fallback.");
    insertLogical (
        new AvailableMove($x, $y + 1, Move.UP)
    );
end

rule "Determine whether a position to the bottom is available to be moved into"
salience 10
when
    not TargettedCollectible()
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == $x, y == ($y - 1))
then
    logger.debug("DOWN fallback.");
    insertLogical (
        new AvailableMove($x, $y - 1, Move.DOWN)
    );
end

################################################################################
######                                  MOVE                               #####
################################################################################

rule "Pick one of the available moves at random"
when
    CurrentTurn()
    $moves : ArrayList( size > 0 ) from collect( AvailableMove() )
then
    int size = $moves.size();
    Random random = new Random(System.nanoTime());
    AvailableMove move = (AvailableMove)$moves.get(random.nextInt(size));
    channels["decision"].send(move.getMove());
end